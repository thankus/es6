generator 函数
es6引入了generator函数，可以通过yield关键字，把函数的执行流挂起，未改变执行流程提供了可能，从而为异步编程提供了解决方案

generator有两个区分于普通函数的部分：
  一是在function后面，函数名之前有个 *
  函数内部有yield表达式
其中*用来表示函数为generator函数，yield用来定义函数内部的状态
function* func(){
 console.log("one");
 yield '1';
 console.log("two");
 yield '2'; 
 console.log("three");
 return '3';
}
执行机制
调用generator函数和普通函数一样，在函数后面加上（）即可，但是generator函数不会像普通函数一样立即执行，而是返回一个指向内部状态的指针，所以要调用遍历器对象Iterator的next方法，指针就会从函数头部或者上一次停下来的地方开始执行
f.next();
// one
// {value: "1", done: false}
 
f.next();
// two
// {value: "2", done: false}
 
f.next();
// three
// {value: "3", done: true}
 
f.next();
// {value: undefined, done: true}
第一次调用next方法时，从generator函数的头部开始执行，显示打印了one,执行到yield就停下来，并将yield后面表达式的值1作为返回对象的value属性值，此时函数还没有执行完，返回对象的done属性值是false
第二次调用 next 方法时，同上步 。

第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为true 。

第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 {value: undefined, done: true}。

函数返回的遍历器对象的方法
  next方法
    一般情况下，next方法不传入参数的时候，yield表达式的返回值是undefined，当next传入参数的时候，该参数会作为上一步yield的返回值
    function* sendParameter(){
      console.log("start");
      var x = yield '2';
      console.log("one:" + x);
      var y = yield '3';
      console.log("two:" + y);
      console.log("total:" + (x + y));
  }
  next不传参
  var sendp1 = sendParameter();
  sendp1.next();
  // start
  // {value: "2", done: false}
  sendp1.next();
  // one:undefined
  // {value: "3", done: false}
  sendp1.next();
  // two:undefined
  // total:NaN
  // {value: undefined, done: true}
  next传参
  var sendp2 = sendParameter();
  sendp2.next(10);
  // start
  // {value: "2", done: false}
  sendp2.next(20);
  // one:20
  // {value: "3", done: false}
  sendp2.next(30);
  // two:30
  // total:50
  // {value: undefined, done: true}
  除了使用next，还可以使用for...of循环遍历generator函数生产的Iterator 对象
  return 方法
  return方法返回给定值，并结束遍历genrator 函数
  return方法提供参数时，返回该参数，不提供参数时，返回undefined
  function* foo(){
    yield 1;
    yield 2;
    yield 3;
  }
  var f = foo();
  f.next();
  // {value: 1, done: false}
  f.return("foo");
  // {value: "foo", done: true}
  f.next();
  // {value: undefined, done: true}
  throw 方法
  throw 方法可以再 Generator 函数体外面抛出异常，再函数体内部捕获。
  var g = function* () {
    try {
      yield;
    } catch (e) {
      console.log('catch inner', e);
    }
  };

  var i = g();
  i.next();

  try {
    i.throw('a');
    i.throw('b');
  } catch (e) {
    console.log('catch outside', e);
  }
  // catch inner a
  // catch outside b
  遍历器对象抛出了两个错误，第一个被 Generator 函数内部捕获，第二个因为函数体内部的catch 函数已经执行过了，不会再捕获这个错误，所以这个错误就抛出 Generator 函数体，被函数体外的 catch 捕获。
  
